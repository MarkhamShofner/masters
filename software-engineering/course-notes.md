Foundations of Software Engineerings,
  Software engineering is concerned with the construction of large software systems. Such systems require the efforts of a group of people over a large span of time. This course will focus on techniques that have been found to be effective in the development of these systems. There will be lectures, readings, discussions, research, and a group project. The topics discussed will include software management, software analysis and design techniques, software quality, testing and maintenance.
  +;

Module 1: Intro,
  - Define Software Engineering.
  - Explain why an engineering discipline is needed for software development today.
  - Discuss some of the problems that result if you donâ€™t apply engineering to the development of software.
  - Recognize the goals and principles of Software Engineering.
  - Argue why Software Engineering is, and is not, a Profession.
  +;
Definitions,
  - what work products of software are, and the various tasks that must be completed in order to create them
  - what makes something an engineering discipline
  +;
Complexity,
  LOC (Lines of Code) and the more important Complexity (relationships between the lines of code) are both expanding at a similar rate posited in Moore's law. Exponential increases in complexity can cause major issues when creating and maintaining large codebases. How can software engineering address some of these concerns?
  +;
Goals,
  - Modifiability
  - Efficiency
  - Reliability
  - Usability
  +;
Principles,
  - Modularity
  - Abstraction
  - Encapsulation. High cohesion. Low coupling (simple interfaces).
  +;

Module 2: Process Models,
  - Describe the purpose of software life cycle models.
  - Discuss the benefits of using a life cycle model.
  - Compare and contrast different life cycle models.
  - Differentiate between plan-driven and Agile processes.
  - Select appropriate life cycle model choices for a specific set of project characteristics.
  +;
Software Process / Software Lifecycle,
  - Framework that provides terminology, activity, order/timelines, and project deliverables.
  - Iterative, AGILE, Waterfall, Hybrids...
    - Defining requirements up front with thorough analysis, design, development, testing, deployment - all in distinct phases - with the goal of hitting a specific timeline within a specific budget.
    - then Agile Manifesto, recognizing the shape of modern software development and the competitive advantage gained through responding quickly to changing requirements/landscapes.
  +;
Agile options,
  many types:
    - scrum most common - sprints, team size
    - kanban - no time cycle. to-do, doing, done. (tugboat team)
  +;

Module 3: Software Project Management,
  - Describe the activities in the project management process.
  - Describe the umbrella activities associated with project management.
  - Compare and contrast the different types of estimating techniques used in project planning.
  - Develop a work breakdown structure for a project.
  - Develop a project network diagram and be able to estimate project duration.
  - Describe common types of project risks and how they can be managed.
  - Incorporate uncertainty in project estimates.
  - Compare and contrast the earned value method of measuring project progress with less effective progress measures.
  +;
Team Size and Communication,
  - If we treat the team as a graph, then the expansion if edges between nodes grows exponentially as we add new members, and full communication between each node becomes harder (to keep everyone perfectly in sync)
  - Members will spend more time communicating as team size grows.
  [this isn't to say that we shouldn't have large teams, but to say that "add more people" to a late project/product doesn't always have the intended effects]
  +;
Ranges and Probabilities,
  - Provide ranges and probabilities (for cost, time, risk) to give a proper sense of accuracy/precision and not have teams/individuals be bound to nonreal concreteness. Hone the range throughout the course of the project and converge estimations more tightly bound until the end point.
  +;
Methods for Estimation,
  - Delphi Estimating Process
  - Rule of Thumb
  - Algorithmic Estimation Models
  - Function Point Estimating
  - Activity-Based Estimating - been shown to be the most accurate in practice, but can be quite complex to identify and manage
  +;
Activity-Based Estimating,
  - Task Identification
  - Effort Estimation
  - Cost Estimation
  - Task Sequencing
  - Schedule Estimation
  +;
Three Point Technique for Estimation (tasks projects costs etc.),
  - best case, most likely, worst case
  - provides ranges and a sense of accuracy. normal distribution, long tails depending on the
  +;








+;
